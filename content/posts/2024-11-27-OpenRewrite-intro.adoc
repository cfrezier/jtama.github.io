---
layout: :theme/post
title: "OpenRewrite: Refactoring as code"
description: Introduction à OpenRewrite
image: https://images.unsplash.com/photo-1589152144820-692b189e0b34?q=80&w=3474&auto=format&fit=crop&ixlib=rb-4.0.3
tags: java, tools
author: jtama
draft: true
---

image::{site.imagesDirUrl.resolve('openrewrite/logo.svg')}[Logo d'openrewrite]

[%collapsible]
====
_Mieux vaut prévenir que guérir_, je n'utiliserai pas le mot _reusiner_, et certainement pas non plus le mot _refactoriser_. Cette note sera donc pleine d'anglicismes. La vie.
====

Alors comme ça vous voulez _refactor_ code ? Voici les différentes options qui s'offrent habituellement à vous (je sais, il y en a d'autres) :

* Pour commencer le fameux (ou l'infâme) *Chercher/Remplacer*, plus connu sous le nom de `Ctrl+F/Ctrl+R`.
* La technique un peu plus avancée de l'expression régulière, aussi connue sour le nom de _Les regexps c'est illisible 15 jours après les avoir écrites_.
* Mais de façon plus probable, vous utiliserez le menu _click droit_ de votre IDE, ou un bon paquet de raccourcis clavier, technique également connue sous le nom de _tu peux toujours courir, jamais tu reproduiras ce que j'ai fait_.

Si vous êtes dans le cas d'un refactoring qui nécessite plus d'une étape et/ou qui touche à de nombreux fichiers, vous êtes très probablement condamné à suivre un guide de migration, aussi triste qu'un long dimanche de pluie.


Disons que vous vouliez par exemple migrer de `JUnit 4` à `JUnit 5`, ou bien de `Spring Boot 2` à `Spring Boot 4`, ou  d'`Hibernate 4` à `Hibernate 6`, ou encore de `Java 8` à `Java 21`. Il vous faudrait pour cela :

* Faire les monter de versions dans vos fichiers de configuration `Maven` ou `Gradle`
* Changer vos imports
* Changer vos annotations
* Changer vos invocations de méthodes
* Peut-être changer vous signature de méthodes
* Changer les noms de propriété
* Je ne sais quoi encore

C'est chronophage, lourd, sujet aux erreurs et aux oublis.

Mais il y a un petit nouveau dans le monde du refactoring : *OpenRewrite*.

== The big picture

OpenRewrite est un outil de refactoring qui a été créé par https://www.moderne.ai[Moderne].

C'est un projet open source sous licence Apache 2.0, et il fait maintenant partie de la https://www.commonhaus.org/[Fondation Commonhaus] pour une gouvernance plus ouverte.

Il a commencé avec un fort accent sur Java (et ses fichiers de configuration : properties et yaml), mais il s'étend maintenant à d'autres langages et formats de fichiers :

* Langages de programmation :
** Java
** Kotlin
** Groovy
* Formats de données :
** XML
** Properties
** YAML
** JSON
** Protobuf
* Outils de build :
** Maven
** Gradle

Je me concentrerai uniquement sur l'écosystème Java dans cet article.

== Concepts

Les principaux concepts d'OpenRewrite que vous devez garder à l'esprit sont les suivants.

=== _**L**ossless **S**yntax **T**ree_

Le code source que vous souhaitez consulter et transformer est rendu accessible via un *_LST_*. C'est un arbre de syntax abstrait (*AST*) contenant en plus des information de formatage. Une représentation asbtraite du code source pour le rendre plus facile  à manipuler.

L'élément atomique pour effectuer le refactoring est appelé une _recette_. Elle peut avoir des pré-vérifications et une ou plusieurs transformations associées.

Mais elle peut aussi avoir une liste de recettes qui s'appliqueront séquentiellement, et donc la façon d'implémenter un refactoring complexe est de composer des _recettes_, et à la fin, cela s'appelle aussi une recette.

¯\\_(ツ)_/¯ Ne blâmez pas le messager.


== Que propose-t-il ?

OpenRewrite n'est en fait pas une seule chose, c'est un ensemble d'outils qui fonctionnent ensemble.

. Le module principal, bien sûr, qui contient toute la représentation générique des langages et la logique de refactoring commune.
. Un module pour chaque langage, avec des API et SDK dédiés pour une cible spécifique (Java, XML, Yaml, etc).
. De nombreux modules contenant des recettes pour un sous-ensemble d'intérêt spécifique, telles que les recettes de frameworks de test, les recettes de Spring, les recettes de Quarkus, l'identification et la correction des problèmes d'analyse statique, etc.
